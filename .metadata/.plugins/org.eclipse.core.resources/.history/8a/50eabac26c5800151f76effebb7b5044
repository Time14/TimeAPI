package physics;

import advancedMath.Vector2f;
import advancedMath.VectorXf;
import debug.Debug;

public class Body {
	/*
	 * 		Body - Something that can simulate physics, with a collider. (Trigger or not)
	 * 		Trigger
	 * 		iMass
	 * 		Elasticity
	 * 		W, H
	 * 		Position
	 * 		Scale
	 * 		Velocity
	 * 		CheckCollision(body-b)
	 */
	
	boolean trigger;
	boolean absolute;

	float invMass;
	float epsilon;
	float mu;
	
	Vector2f dim;
	Vector2f pos;
	Vector2f vel;
	
	public Body(float x, float y, float w, float h) {
		
		trigger = false;
		absolute = false;
		
		invMass = 1;
		epsilon = 1;
		mu = 1;
		
		dim = new Vector2f(w, h);
		pos = new Vector2f(x, y);
		vel = new Vector2f(0, 0);
	}
	
	public boolean isTrigger() {
		return trigger;
	}

	public Body setTrigger(boolean trigger) {
		this.trigger = trigger;
		return this;
	}
	
	public boolean isAbsolute() {
		return trigger;
	}

	public Body setAbsolute(boolean absolute) {
		this.absolute = absolute;
		return this;
	}

	public float getInvMass() {
		return invMass;
	}

	public Body setMass(float mass) {
		this.invMass = 1 / mass;
		return this;
	}

	public float getEpsilon() {
		return epsilon;
	}

	public Body setEpsilon(float epsilon) {
		this.epsilon = epsilon;
		return this;
	}

	public float getFriction() {
		return mu;
	}

	public Body setFriction(float f) {
		this.mu = f;
		return this;
	}

	public Vector2f getDim() {
		return dim;
	}

	public Body setDim(Vector2f dim) {
		this.dim = dim;
		return this;
	}

	public Vector2f getPos() {
		return pos;
	}

	public Body setPos(Vector2f pos) {
		this.pos = pos;
		return this;
	}

	public Vector2f getVel() {
		return vel;
	}

	public Body setVel(Vector2f vel) {
		this.vel = vel;
		return this;
	}
	
	public Body freezeVelocity() {
		this.vel.setX(0);
		this.vel.setY(0);
		return this;
	}
	
	public void checkCollision(Body body, PhysicsEngine pe) {
		
		float overlapX = 2 * Math.abs(this.dim.getX() + body.dim.getX()) - Math.abs(this.pos.getX() - body.pos.getX());
		if(overlapX < 0) return;		

		float overlapY = 2 * Math.abs(this.dim.getY() + body.dim.getY()) - Math.abs(this.pos.getY() - body.pos.getY());
		if(overlapY < 0) return;
		
		Vector2f normal = new Vector2f(0, 0);
		float depth = 0;
		if(overlapX < overlapY) {
			normal.setY(1);
			depth = overlapY;
		}
		else {
			normal.setX(1);
			depth = overlapX;
		}
		
		new Collision(pe, normal, depth, this, body);
		return;
	}
	
	public void push(Vector2f force) {
		vel.add(force.scale(invMass));
	}
	
	public void addVel(VectorXf vel) {
		this.vel.add(vel);
	}
	
	public void update(float delta) {
		//TODO
		Debug.Log(delta.toString());
		pos.add(vel.clone().scale(delta));
	}
	
}
