package physics;

import advancedMath.Vector2f;
import advancedMath.VectorXf;
import debug.Debug;

public class Collision {
	
	private Body[] bodies;
	
	private Vector2f normal;
	
	private float depth;
	
	public Collision(PhysicsEngine pe, Vector2f normal, float depth, Body ... b) {
		this.normal = normal;
		this.depth = depth;
		
		bodies = b;
		
		pe.addCollision(this);
	}
	
	public void solve() {
		
		Vector2f tangent = new Vector2f(normal.getY(), -normal.getX());
		
		VectorXf v = bodies[0].getVel().clone().add(bodies[1].getVel());
		float dir = normal.dot(v);
		
		if(0 > dir) return;
		
		float p = (1/bodies[0].getInvMass()) + (1/bodies[1].getInvMass());
		float e = (float) (((bodies[0].getEpsilon() + bodies[1].getEpsilon()) * 0.5 + 1) * 0.5);

		p *= v.getMagnitude() * e;
		
		bodies[0].push(normal.scale(p));
		bodies[1].push(normal.scale(-1));
		
		//TODO: Add in friction!
		v = bodies[0].getVel().clone().add(bodies[1].getVel());
		dir = tangent.dot(v);
		
		if(dir == 0) return;
		
		float mu = (bodies[0].getFriction() + bodies[1].getFriction()) * 0.25f * 0.5f;
		
		mu = normal.dot(v) * mu;
		
		bodies[0].push(tangent.scale(mu));
		bodies[1].push(tangent.scale(-1));
	}
	
	public void move() {
		float d = 0.02f;
		for(Body b : bodies) {
			if(!b.isAbsolute()){
				b.getPos().setX(b.getPos().getX() + normal.getX() * depth * d);
				b.getPos().setY(b.getPos().getY() + normal.getY() * depth * d);
			}
		}
	}
}
